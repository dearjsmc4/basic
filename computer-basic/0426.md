## ADT(abstract data type), 추상 자료형  

자료구조의 인터페이스(함수 시그니쳐를, 함수 사용법을) 명시해 놓은 것. 기능 명세.  
구체적인 구현설명이 들어가면 안 된다.  
-> 인터페이스와 내부구현의 분리, 추상화.  

이미 존재하는 자료구조를 이용해서 새로운 자료구조를 구현.  
스택 구현 방법:  
1. 배열  
2. 연결 리스트  
3. 파이썬의 리스트  

### 스택  
접시쌓기를 생각해보자.  
접시를 하나씩 위로 쌓는다면 보통은 위에서부터 하나씩 가져간다.  
이처럼, 데이터1, 데이터2, 데이터3, 데이터4 가 쌓였을 때 데이터4 부터 먼저 사라지는 것.  
제일 나중에 들어오면 제일 먼저 나간다. : `Last In First Out` = 후입선출  

pop: 삭제하면서 반환  
peek: 다음으로 나올 데이터를 반환만 하고 삭제하지 않음  

일반적으로 스택의 맨 위 데이터는 top 으로 가리킨다.  

*나중에 꼭 풀어볼 것*  
1. 후위 표기법 계산기  
2. 미로찾기  


### 큐  
줄서기와 같다.  
맨 처음에 데이터1이 들어오고 그 다음에 데이터2, 데이터3가 들어온다면  
제일 먼저 온 데이터1이 먼저 나간다. : `First In First Out` = 선입선출  

## 연결 리스트(linked list)  
1. `싱글 링크드 리스트`  
노드가 데이터 + 링크    
싱글 링크드 리스트의 노드는 데이터에 대한 링크가 하나이다.  
링크가 하나만 있으면 양방향이 아니게 된다.  
1 -> 2 -> 1 이 안 됨.  
2. `더미 더블 링크드 리스트` -> 이중 연결 리스트  
노드가 링크 + 데이터 + 링크  
링크가 두 개이기 때문에 양방향이다.  
1 -> 2 -> 1 이 가능함. 

`더미 노드`:  
- 데이터가 없다  
- 구현 편의성이 높아지면서 에러 가능성이 낮다  
    구현이 좋아진다 = 프로그래머의 실수를 줄일 수 있다  
`dummy`(head)~`1`~`2`~`3`~`dummy`(tail)

- delete  
reference count 가 0 이 되면  
(어떤 값을 참조하는 것들이 모두 사라지면)  
garbage collection 에 의해 사라진다.  

delete 도 이와 비슷하게  
지우려는 노드를 참조하는 다른 노드의 연결을 끊어버리면 된다.  


## 배열과 링크드리스트의 차이  

**배열 :**  
실제 메모리에도 데이터가 일렬로 들어간다.
인덱싱이 가능하므로 검색도 빠르다. O(1)  
단, 데이터 삽입이나 삭제를 할 때 최악의 경우 O(n)  
검색을 자주 할 때 배열을 쓴다.  

**연결리스트 :**  
실제 메모리에서 데이터가 일렬로 들어가지 않고 흩어져있으며 서로 연결되어 있다.  
인덱싱을 하려면 모든 데이터를 순회해야 하므로 검색이 느리다. O(n)  
데이터 삽입을 할 때 싱글 링크드 리스트의 경우 O(1),  
더블 링크드 리스트의 경우도 O(1).  
삽입과 삭제를 자주 할 때 연결리스트를 쓴다.  

# 앞으로 공부하라고 하신 내용  

linked list, stack, queue 는 선형 자료구조.  
앞으로는 비선형 자료구조도 공부해야 할 것.  

- tree(이진트리)  
    - 순회(travorsal)  
        - 전위(preorder)  
        - 중위(inorder)  
        - 후위(postorder)  
        -> 전위, 중위, 후위는 스택의 일종이고, 스택은 DFS의 일종.  
            반복문과 재귀로 구현  
        - 레벨 순서(level order)  
- BST(Binary Search Tree)  
    O(n^2)  
- 균형이진트리 (Balanced, self balancing)  
    - AVL 트리  
    - RED-BLACK 트리  

- B-Tree (데이터베이스의 인덱스에 쓰임)  
    : 균형이진트리 + 하드웨어 아키텍쳐  

- Heap (완전이진트리, 배열로 구현한다)  

- Hash Table(map)  
    - hash function  
    - collision(충돌)  
        - chaining(체이닝)  
        - open-addressing 기법  

- Graph(그래프)  
    - 순회  
        - DFS (깊이 우선 탐색) -> 스택 기반  
        - BFS (너비 우선 탐색) -> 큐 기반  
    - MST(Minimum Spanning Tree) 최소 신장 트리  
        - 그리디 알고리즘 기반  
        - kruskal algorithm  
        - prim algorithm  
    - 최단 경로 문제(shortest path)  
        - dijkstra algorithm -> 그리디 알고리즘  
        - Balman-ford algorithm  
        - flord-warshall -> 다이나믹 프로그래밍  

