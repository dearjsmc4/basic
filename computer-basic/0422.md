# 함수  

1. namespace  
2. stack frame  
3.  call by value  
    call by reference  
    call by object reference  

*"왜 call by value 와 call by reference 를 나누는가?"*  

## 전역변수 vs 지역변수  

- 지역변수가 생기는 시점은?  
`def func(): b=20`  
라고 함수를 선언해둘 때가 아니라, 함수를 실행할 때.  

namespace = 변수가 저장되어 있는 공간. 함수가 가지는 자기만의 공간.  

## stack frame  

함수가 실행될 때 함수 내부적으로 연산에 필요한 지역변수들이 쌓이는 공간.  
블로킹이 걸리면 새로운 함수에게 다시 주도권이 넘어감.  
함수 실행(연산)이 끝나면 연산에 필요한 변수들은 사라지고 스택프레임도 사라짐.  
그리고 블로킹 걸렸던 시점에서부터 다시 실행이 되고 원래 함수에게 주도권 넘어감.  
함수 실행이 종료되면 연산에 필요없는 변수가 다 사라지고,  
실행 주도권은 다시 글로벌 프레임으로 넘어온다.  
(파이썬 튜터로 스택프레임을 비주얼적으로 보면 좋다.)  

스택프레임이 쌓였을때 a 가 실행되는 동안 b가 블로킹걸린다 -> 동기  
b : a 가 다 실행이 될때까지 기다릴거야.  

io 함수가 호출이되면 바로 반환 후, 실행을 web api 에게 맡김. -> 비동기  
io 실행이 끝나면(ex: 유투브 데이터를 다 받으면) queue에 넣어두고 콜스택이 빌 때까지 기다림.  
콜스택이 다 비었음을 이벤트루프가 알려주면, 큐에서 함수가 콜스택으로 넘어가서 실행됨.  

- call by value :  
    변수의 값 10을 복사해서 단순히 **값**을 스택프레임에 넘겨주는 것.  
- call by reference :  
    변수의 값이 아니라 **주소값**을 전달함. = 참조값을 전달하는 것과 같다.  
    주소값을 알고 잇으면 주소값을 통해 접근할 수 있다.  
    원래 블로킹 상태라면, 실행 중인 함수의 프레임을 벗어나서 참조할 수 없는데,  
    주소값으로 전달하면 주소값을 참조하여 **현재 실행중인 프레임의 바깥 스택프레임의 변수에 접근할 수 있다.**  
    `*a = 30` -> a의 메모리 자체에 접근하여, 그 메모리에 값 30을 넣겠다.  

**call by value와 call by reference의 차이**  
-> 새로운 스택프레임이 쌓였을 때  
- call by value : 그 어떤 변수를 이용하더라도 바깥으로 접근할 수 없다.  
실행하고 있는 프레임 바깥의 데이터에 접근하는게 완벽히 불가능하다.  
- call by reference : 스택프레임이 갈라지고, 새로운 프레임이 실행하는 상황에서 특정 변수를 이용해  
바깥 프레임의 데이터에 접근하여 값을 수정하는 것이 가능하다.  