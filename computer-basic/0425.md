
## Internet(네트워크 계층)  
 
IP는 IP라우팅을 한다.  
인터넷 계층 : 아이피.(아이피주소는 내가 데이터를 보내고자 하는 상대 호스트 컴퓨터)  
최종적으로 도달하는 **호스트를 특정**하기 위해 아이피주소가 필요함.  
상대방의 호스트를 특정하기 위한 **아이피주소를 관리**하는 계층이 네트워크 계층.  
강사님 추천 책: "TCP/IP 완벽 가이드"  

**NAT** : 호스트1이 유투브에게 데이터를 요구하면 유투브는 공인아이피인 라우터까지는 보낼 수 있는데 정확히  
어느 호스트가 보낸 건지 사설아이피까지는 알 수 없다. 그렇다고 늘 브로드캐스트로 보낼 수는 없다.  
그래서 라우터는 랜카드 중 하나를 임대하여 사설 아이피를 공인 아이피와 매핑한다.  
그리고 소스 아이피를 자신의 공인아이피로 바꿔서 보낸다.  
서버가 영상을 공인아이피로 보내면, 변환테이블에서 공인아이피와 연결된 사설아이피를 찾는다.  
그리고 사설아이피를 다시 목적지로 설정하여 보내준다. 랜카드가 많이 필요하다는 단점이 있다.  

**NAPT** : 호스트가 서버와 통신하고자 할때, 모든 호스트들이 같은 랜카드를 빌려오되,  
구분을 해야하므로 포트번호까지 이용하여 구분한다. 같은 123.108.157.1 이라는 랜카드를 써도  
포트번호를 달리해서 쓰면 구분지을 수 있는 것이다.  


## Transport(전송계층): 포트담당  

특정 컴퓨터에게 데이터가 잘 도착했을 때 해당 **프로세스**에게 데이터를 전달하기위해 `포트번호`가 필요.  
이 포트는 패킷이 필요한 프로세스를 특정하기 위해 사용된다.  
이 **포트를 관리**하는 계층이 전송계층. 포트번호는 2^16-1 까지 할당가능하다.  
패킷에는 아이피주소 말고도 포트번호가 쓰여있어서,  
해당 포트번호가 특정하는 프로세스에게 데이터를 전송된다.  
ex) 데이터를 보내긴 보내는데, 유투브 프로세스가 3개 돌아가고 있다면 그 중 어느 프로세스에 데이터를  
    보낼 것인가?

서버에는 소켓이 많다. 서버는 특정 컴퓨터의 특정 프로세스일 뿐이다. 
포트가 특정 프로세스를 특정한다고 했는데, 포트는 소켓에 부여된 숫자이다.  
이 숫자가 0부터 2^16-1 까지. 2바이트짜리 정수.  
소켓에는 두 가지 종류가 있다.  

1. 데이터를 전송하고 있는 `데이터 소켓`  
실제로 클라이언트와 일대일로 매핑되어 데이터를 주고 받는다.  

2. 서버를 대표하는 `리스닝 소켓`  
클라이언트가 리퀘스트를 날릴 때 서버에서 데이터를 받는 소켓  
리스닝 소켓은 클라이언트로부터 최초의 접속 요청을 받는 소켓  
접속 후에 실제로 데이터를 주고받는 것은 데이터 소켓  

`well-known port`: 자주 쓰이는 유명한 포트번호.  
0~1023 번까지 있는데 서버가 특정 서비스에 따라 특정 포트를 쓴다.  


전송계층에는 두 가지 프로토콜이 있다.  

## TCP / UDP

- **TCP**  
신뢰도가 높다. 패킷이 유실되면 **재전송**을 해준다. HTTP는 일반적으로 TCP 위에서 돈다.  
패킷을 보낸 다음에 상대방이 패킷을 잘 받았는지 인증을 받아서 확인한다.  
-> 패킷이 유실되었는지 계속 관리해야하기 때문에 네트워크에 부담이 된다.  
파일 전송이나 메일 전송은 TCP를 이용한다.  
연결 지향성: 서버와 호스트가 데이터를 주고받을 때 소켓을 가지고 접속과 연결이 되어야 한다.  

- **UDP**  
신뢰도가 낮다. 패킷이 유실되더라도 재전송을 해주지 않는다. 보내면 끝.  
-> 한번 보내면 끝이기 때문에 가볍고 빠르다.  
동영상이나 빠른 속도가 필요한 게임 등은 UDP를 이용한다.  
비연결 지향성: 접속이나 연결이 없이 그냥 보내기만 한다.  


## Application (응용, 표현, 세션 계층)  

`Secure Socket Layer(SSL)`(Transport Layer Security)를 어플리케이션과 트랜스포트 사이에 끼워넣는다.  
이 레이어는 **암호화**를 한다. 내가 html 과 js를 만들어서 보내면  
다른 해커가 스푸핑을 통해서 파일들을 뺏더라도 암호화가 되어있어서 볼 수 없다.  
받는 상대방은 **복호화**를 해서 볼 수 있다.  

- http: 메세지 기반의 프로토콜. 단순한 문자열을 주고 받고 해석함.  
(html 파일이나 js 파일도 결국 문자열일 뿐이다)  
- dns: 도메인 네임 시스템. 사람이 읽고 기억하기 쉬운 이름.  
원래 어떤 사이트에 가려면 아이피주소를 써야하는데,  
우리는 그 누구도 페이스북에 접속하려고 아이피를 적지 않는다. 대신 도메인 위치를 적는다.  
그리고 DNS SERVER 에서 도메인 네임에 대한 아이피를 알려준다.  
받아온 아이피는 캐시로 저장된다.  

`HTTP` : 하이퍼 텍스트 트랜스퍼 프로토콜  
"나 이번에 새로 쓴 논문이 있어 인터넷에 링크 걸어둘게!"
원래는 진짜 정적파일 텍스트만 보는 용도였다.  
http 1.0 이하에서는 연결이 일시적이다. 한번 데이터 주고받으면 끝.  
그런데 점점 컴퓨터 성능이 좋아지니까 이미지나 동영상, 스크립트 파일도 받게 되었다.  
그래서 한번 리퀘스트를 받은 다음에 한번의 리스폰스로 끝나는 게 아니게 되었다.  
그래서 http 1.1부터는 연결을 유지한다. 한번 연결하면 끊지 않고 계속 연결.  
만약 일시적 연결을 원한다면 헤더에 `connection:close` 를 포함하면 된다.  

**메서드**: 클라이언트 요청의 종류  
- `GET` : URL 이 지원하는 자원을 찾아 클라이언트에 전송
- `POST` : 클라이언트가 임의의 데이터를 서버로 보낸다.
주로 form 형식을 사용하며 서버의 프로그램에 전달
- HEAD: GET과 같지만 메세지 본문이 없다. 테스트 용도
- PUT: 지정한 URL에 요청의 본문내용을 저장
- DELETE: 지정한 자원을 지움
- TRACE: 클라이언트가 서버에 보낸 요청의 복사본을 돌려받는다.

### 상태코드
200번대 : 성공  
300번대 : 서버가 옮겨간것같은데 저쪽으로 다시 시도해볼래?  
400번대 : 클라이언트가 잘못했다  
500번대 : 서버가 잘못했다  

컨텐트 협상: 
1. 서버 주도 협상:
    -> 최선 추측
클라이언트가 원하는 것이 없을 때, 요청과 가장 비슷한 것을 가져감.  

2. 에이전트 주도 협상:  
    클라이언트가 자원을 고를 수 있음  
-> 클라이언트: 글 좀 보내봐  
서버: 한국어도 있고 영어도 있고 프랑스어도 있는데... 뭐 보내지?  
클라이언트: Accept - Language: kr;q=0.7, fr;q=0, en;q=0.4  
    "한국어가 최우선이고 한국어 없으면 영어 보내줘. 프랑스어는 있어도 보내지마"  

- random pivot  
리스트의 첫번째, 중간, 마지막 값을 가져와서 중간값을 찾아서 pivot 으로 설정.  
-> 거의 average case 에 가깝게 구현이 되더라는 것이 정설.  

